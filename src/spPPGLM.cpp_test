
SEXP spPPGLM(SEXP Y_r, SEXP X_r,
             SEXP coordsD_r, SEXP family_r, SEXP weights_r,
             SEXP isModPp_r, SEXP knotsD_r, SEXP coordsKnotsD_r, 
             SEXP betaPrior_r, SEXP betaNorm_r, 
             SEXP sigmaSq_r, SEXP tauSq_r, SEXP nu_r, SEXP phi_r, SEXP beta_r, SEXP w_str_r,
             SEXP covModel_r, SEXP nSamples_r, SEXP verbose_r, SEXP nReport_r)
{    
    arma::vec Y = Rcpp::as<arma::vec>(Y_r);
    arma::mat X = Rcpp::as<arma::mat>(X_r);
    
    arma::mat coordsD = Rcpp::as<arma::mat>(coordsD_r);
    arma::mat knotsD = Rcpp::as<arma::mat>(knotsD_r);
    arma::mat coordsKnotsD = Rcpp::as<arma::mat>(coordsKnotsD_r);
    
    int p = X.n_cols;       // # of betas
    int n = X.n_rows;       // # of samples
    int m = knotsD.n_rows;  // # of knots

    //FIXME
    prior sigmaSq(sigmaSqIG_r);
    prior phiUnif(phiUnif_r);
    prior tauSq(tauSqIG_r);
    prior nu(nuUnif_r);
    prior beta(beta_r);
    prior w_str(w_str_r);

    int nSamples = Rcpp::as<int>(nSamples_r);
    int verbose  = Rcpp::as<int>(verbose_r);
    int nReport  = Rcpp::as<int>(nReport_r);
  
    std::string cv = Rcpp::as<std::string>(covModel_r);
  
    cov_model covModel;
    if (cv == "exponential")    covModel = exp_cov;
    else if (cv == "powexp")    covModel = powexp_cov;
    else if (cv == "matern")    covModel = matern_cov;
    else if (cv == "spherical") covModel = sphere_cov;
    else if (cv == "gaussian")  covModel = gauss_cov;

    std::string family = Rcpp::as<std::string>(family_r);
    arma::vec weights = Rcpp::as<arma::vec>(weights_r);

    bool isModPP = Rcpp::as<bool>(isModPp_r);

    

    if(verbose){
        Rcpp::Rcout << "----------------------------------------\n";
        Rcpp::Rcout << "\tGeneral model description\n";
        Rcpp::Rcout << "----------------------------------------\n";
        Rcpp::Rcout << "Model fit with " << n << " observations.\n";
        Rcpp::Rcout << "Number of covariates " << p << " (including intercept if specified).\n";
        Rcpp::Rcout << "Using the " << covModel << " spatial correlation model.\n";
        
        std::string mod_str = (isModPP) ? "modified" : "non-modified"; 
        Rcpp::Rcout << "Using " << mod_str <<  " predictive process with %i knots.\n";
        Rcpp::Rcout << "Number of MCMC samples " << nSamples << ".\n\n";

        Rcpp::Rcout << "Priors and hyperpriors:\n");
        if(betaPrior == "flat") {
            Rcpp::Rcout << "\tbeta - flat.\n";
        } else {
            Rcpp::Rcout << "\tbeta - normal:\n"
                        << "\t\tmu: " << beta.mu << "\n"
                        << "\t\tsd: " << beta.sd << "\n";
        }
    } 





    if (verbose) {
        Rcpp::Rcout << "-------------------------------------------------\n"
                    << "                   Sampling                      \n"
                    << "-------------------------------------------------\n";
    }

    logPostCurrent = R_NegInf;

    arma::mat M = cov_mat;
    arma::mat S = arma::chol(M).t();
    
    int nParams = 4;

    for(int s = 0; s < nSamples; s++){

        arma::vec U = S * arma::randn<arma::mat>(p+nParams);

        arma::vec param_cand = param_cur + U;

        //propose
        arma::vec beta_cand = beta_cur+param_cand(arma::span(0,p-1));
        
        arma::vec param_cand(nParams);
        for(int j=0; j != nParams; j++) {
            param_cand(j) = param_transform(param_cur(j), hyper_params[j], trans_type[j] )
        }
        mvrnorm(&candSpParams[betaIndx], &spParams[betaIndx], betaTuning, p, false);
        F77_NAME(dcopy)(&p, &candSpParams[betaIndx], &incOne, beta, &incOne);


        arma::vec ws_cand = ws_cur + sqrt(ws_tuning) % arma::randn<arma::vec>(m);

        arma::mat Cs = calc_cov(cov_model, knotsD);
        arma::mat c = calc_cov(cov_model, coordsKnotsD);

        arma::mat Cs_U = arma::chol(Cs);
        arma::mat Cs_U_inv = arma::inv( arma::trimatu(Cs_U) );
        arma::mat Cs_inv = Cs_U_inv * Cs_U_inv.t();

        double det_cand = 2*arma::accu(arma::log(arma::diagvec(Cs_U)));

        arma::mat w_cand = c * Cs_inv * ws_cand; // (n x m) (m x m) (m x 1) = n x 1

        
        double loglik_cand = 0.0;

        if (betaPrior == "normal") {
            for (i = 0; i < p; i++) {
                loglik_cand += dnorm(beta[i], betaMu[i], betaSd[i], 1);
            }
        }

        logPostCand += -1.0*(1.0+sigmaSqIGa)*log(sigmaSq)-sigmaSqIGb/sigmaSq+log(sigmaSq); 

        logPostCand += log(phi - phiUnifa) + log(phiUnifb - phi); 

        if(covModel == "matern"){
            logPostCand += log(nu - nuUnifa) + log(nuUnifb - nu);   
        }

        F77_NAME(dgemv)(ntran, &n, &p, &one, X, &n, beta, &incOne, &zero, tmp_n, &incOne);

        if (family == "binomial") {
            logPostCand += binomial_logpost(n, Y, tmp_n, wCand, weights);
        } else if (family == "poisson") {
            logPostCand += poisson_logpost(n, Y, tmp_n, wCand);
        } else {
            error("c++ error: family misspecification in spGLM\n");
        }

        //(-1/2) * tmp_n` *  C^-1 * tmp_n
        F77_NAME(dsymv)(upper, &m, &one,  C_str, &m, w_strCand, &incOne, &zero, tmp_m, &incOne);
        logPostCand += -0.5*detCand-0.5*F77_NAME(ddot)(&m, w_strCand, &incOne, tmp_m, &incOne);

        //
        //MH accept/reject  
        //      

        //MH ratio with adjustment
        logMHRatio = logPostCand - logPostCurrent;

        if(runif(0.0,1.0) <= exp(logMHRatio)){
            F77_NAME(dcopy)(&nParams, candSpParams, &incOne, spParams, &incOne);
            F77_NAME(dcopy)(&n, wCand, &incOne, wCurrent, &incOne);
            F77_NAME(dcopy)(&m, w_strCand, &incOne, w_strCurrent, &incOne);
            logPostCurrent = logPostCand;
            accept++;
            batchAccept++;
        }


        /******************************
            Save samples and report
        *******************************/
        F77_NAME(dcopy)(&nParams, spParams, &incOne, &samples[s*nParams], &incOne);
        F77_NAME(dcopy)(&n, wCurrent, &incOne, &w[s*n], &incOne);
        F77_NAME(dcopy)(&m, w_strCurrent, &incOne, &w_str[s*m], &incOne);

        //report
        if(verbose){
            if(status == nReport){
                Rprintf("Sampled: %i of %i, %3.2f%%\n", s, nSamples, 100.0*s/nSamples);
                Rprintf("Report interval Metrop. Acceptance rate: %3.2f%%\n", 100.0*batchAccept/nReport);
                Rprintf("Overall Metrop. Acceptance rate: %3.2f%%\n", 100.0*accept/s);
                Rprintf("-------------------------------------------------\n");
                #ifdef Win32
                R_FlushConsole();
                #endif
                status = 0;
                batchAccept = 0;
            }
        }
        status++;

        R_CheckUserInterrupt();
    } //end sample loop
    PutRNGstate();
  
    //final status report
    if (verbose) {
        Rprintf("Sampled: %i of %i, %3.2f%%\n", s, nSamples, 100.0*s/nSamples);
        Rprintf("-------------------------------------------------\n");
        #ifdef Win32
        R_FlushConsole();
        #endif
    }

    //untransform variance variables
    for(s = 0; s < nSamples; s++) {
        samples[s*nParams+sigmaSqIndx] = exp(samples[s*nParams+sigmaSqIndx]);
        samples[s*nParams+phiIndx] = logitInv(samples[s*nParams+phiIndx], phiUnifa, phiUnifb);

        if(covModel == "matern") = samples[s*nParams+nuIndx] = logitInv(samples[s*nParams+nuIndx], nuUnifa, nuUnifb);
    }

    //calculate acceptance rate
    REAL(accept_r)[0] = 100.0*accept/s;

    //make return object
    SEXP result, resultNames;

    int nResultListObjs = 4;

    PROTECT(result = allocVector(VECSXP, nResultListObjs)); nProtect++;
    PROTECT(resultNames = allocVector(VECSXP, nResultListObjs)); nProtect++;
    
     //samples
    SET_VECTOR_ELT(result, 0, samples_r);
    SET_VECTOR_ELT(resultNames, 0, mkChar("p.samples")); 
    
    SET_VECTOR_ELT(result, 1, accept_r);
    SET_VECTOR_ELT(resultNames, 1, mkChar("acceptance"));
    
    SET_VECTOR_ELT(result, 2, w_r);
    SET_VECTOR_ELT(resultNames, 2, mkChar("sp.effects"));
    
    SET_VECTOR_ELT(result, 3, w_str_r);
    SET_VECTOR_ELT(resultNames, 3, mkChar("sp.effects.knots"));
    
    namesgets(result, resultNames);
    
      //unprotect
    UNPROTECT(nProtect);
    
    return(result);

}

